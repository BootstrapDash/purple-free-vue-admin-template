{"version":3,"file":"vue-slide-bar.min.js","sources":["../node_modules/vue-runtime-helpers/inject-style/browser.js","../src/index.vue","../node_modules/vue-runtime-helpers/normalize-component.js"],"sourcesContent":["const isOldIE = typeof navigator !== 'undefined' &&\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\nexport default function createInjector(context) {\n    return (id, style) => addStyle(id, style);\n}\nconst HEAD = document.head || document.getElementsByTagName('head')[0];\nconst styles = {};\nfunction addStyle(id, css) {\n    const group = isOldIE ? css.media || 'default' : id;\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\n    if (!style.ids.has(id)) {\n        style.ids.add(id);\n        let code = css.source;\n        if (css.map) {\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\n            // this makes source maps inside style tags work properly in Chrome\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\n            // http://stackoverflow.com/a/26603875\n            code +=\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\n                    ' */';\n        }\n        if (!style.element) {\n            style.element = document.createElement('style');\n            style.element.type = 'text/css';\n            if (css.media)\n                style.element.setAttribute('media', css.media);\n            HEAD.appendChild(style.element);\n        }\n        if ('styleSheet' in style.element) {\n            style.styles.push(code);\n            style.element.styleSheet.cssText = style.styles\n                .filter(Boolean)\n                .join('\\n');\n        }\n        else {\n            const index = style.ids.size - 1;\n            const textNode = document.createTextNode(code);\n            const nodes = style.element.childNodes;\n            if (nodes[index])\n                style.element.removeChild(nodes[index]);\n            if (nodes.length)\n                style.element.insertBefore(textNode, nodes[index]);\n            else\n                style.element.appendChild(textNode);\n        }\n    }\n}\n","<template>\n  <div\n    ref=\"wrap\"\n    :id=\"id\"\n    class=\"vue-slide-bar-component vue-slide-bar-horizontal\"\n    :style=\"calculateHeight\"\n    @click=\"wrapClick\">\n    <div\n      ref=\"elem\"\n      class=\"vue-slide-bar\"\n      :style=\"{\n        height: `${lineHeight}px`\n      }\"\n    >\n      <template>\n        <div\n          ref=\"tooltip\"\n          class=\"vue-slide-bar-always vue-slide-bar-tooltip-container\"\n          :style=\"{'width': `${iconWidth}px`}\"\n          @mousedown=\"moveStart\"\n          @touchstart=\"moveStart\"\n        >\n          <span\n            v-if=\"showTooltip\"\n            class=\"vue-slide-bar-tooltip-top vue-slide-bar-tooltip-wrap\"\n          >\n            <slot name=\"tooltip\">\n              <span\n                :style=\"tooltipStyles\"\n                class=\"vue-slide-bar-tooltip\"\n              >\n                {{ val }}\n              </span>\n            </slot>\n          </span>\n        </div>\n      </template>\n      <div\n        ref=\"process\"\n        :style=\"processStyle\"\n        class=\"vue-slide-bar-process\"\n      />\n    </div>\n    <div\n      v-if=\"range\"\n      class=\"vue-slide-bar-range\"\n    >\n      <div\n        v-for=\"(r, index) in range\"\n        :key=\"index\"\n        class=\"vue-slide-bar-separate\"\n        :style=\"dataLabelStyles\"\n      >\n        <span\n          v-if=\"!r.isHide\"\n          class=\"vue-slide-bar-separate-text\"\n        >\n          {{ r.label }}\n        </span>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'vue-slide-bar',\n  data () {\n    return {\n      flag: false,\n      size: 0,\n      currentValue: 0,\n      currentSlider: 0,\n      isComponentExists: true,\n      interval: 1,\n      lazy: false,\n      realTime: false,\n      dataLabelStyles: {\n        'color': '#4a4a4a',\n        'font-family': 'Arial, sans-serif',\n        'font-size': '12px',\n        ...this.$props.labelStyles\n      }\n    }\n  },\n  props: {\n    data: {\n      type: Array,\n      default: null\n    },\n    id: {\n      type: String,\n      default: 'wrap'\n    },\n    range: {\n      type: Array,\n      default: null\n    },\n    speed: {\n      type: Number,\n      default: 0.5\n    },\n    lineHeight: {\n      type: Number,\n      default: 5\n    },\n    iconWidth: {\n      type: Number,\n      default: 20\n    },\n    value: {\n      type: [String, Number],\n      default: 0\n    },\n    min: {\n      type: Number,\n      default: 0\n    },\n    max: {\n      type: Number,\n      default: 100\n    },\n    showTooltip: {\n      type: Boolean,\n      default: true\n    },\n    isDisabled: {\n      type: Boolean,\n      default: false\n    },\n    draggable: {\n      type: Boolean,\n      default: true\n    },\n    paddingless: {\n      type: Boolean,\n      default: false\n    },\n    tooltipStyles: Object,\n    labelStyles: Object,\n    processStyle: Object\n  },\n  computed: {\n    slider () {\n      return this.$refs.tooltip\n    },\n    val: {\n      get () {\n        return this.data ? this.data[this.currentValue] : this.currentValue\n      },\n      set (val) {\n        if (this.data) {\n          let index = this.data.indexOf(val)\n          if (index > -1) {\n            this.currentValue = index\n          }\n        } else {\n          this.currentValue = val\n        }\n      }\n    },\n    currentIndex () {\n      return (this.currentValue - this.minimum) / this.spacing\n    },\n    indexRange () {\n      return [0, this.currentIndex]\n    },\n    minimum () {\n      return this.data ? 0 : this.min\n    },\n    maximum () {\n      return this.data ? (this.data.length - 1) : this.max\n    },\n    multiple () {\n      let decimals = `${this.interval}`.split('.')[1]\n      return decimals ? Math.pow(10, decimals.length) : 1\n    },\n    spacing () {\n      return this.data ? 1 : this.interval\n    },\n    total () {\n      if (this.data) {\n        return this.data.length - 1\n      } else if (Math.floor((this.maximum - this.minimum) * this.multiple) % (this.interval * this.multiple) !== 0) {\n        this.printError('[VueSlideBar error]: Prop[interval] is illegal, Please make sure that the interval can be divisible')\n      }\n      return (this.maximum - this.minimum) / this.interval\n    },\n    gap () {\n      return this.size / this.total\n    },\n    position () {\n      return ((this.currentValue - this.minimum) / this.spacing * this.gap)\n    },\n    limit () {\n      return [0, this.size]\n    },\n    valueLimit () {\n      return [this.minimum, this.maximum]\n    },\n    calculateHeight () {\n      return this.paddingless ? {} : { 'padding-top': '40px', 'min-height': this.range ? '100px' : null }\n    }\n  },\n  watch: {\n    value (val) {\n      if (this.flag) this.setValue(val)\n      else this.setValue(val, this.speed)\n    },\n    max (val) {\n      if (val < this.min) {\n        return this.printError('[VueSlideBar error]: The maximum value can not be less than the minimum value.')\n      }\n      let resetVal = this.limitValue(this.val)\n      this.setValue(resetVal)\n      this.refresh()\n    },\n    min (val) {\n      if (val > this.max) {\n        return this.printError('[VueSlideBar error]: The minimum value can not be greater than the maximum value.')\n      }\n      let resetVal = this.limitValue(this.val)\n      this.setValue(resetVal)\n      this.refresh()\n    }\n  },\n  methods: {\n    bindEvents () {\n      document.addEventListener('touchmove', this.moving, {passive: false})\n      document.addEventListener('touchend', this.moveEnd, {passive: false})\n      document.addEventListener('mousemove', this.moving)\n      document.addEventListener('mouseup', this.moveEnd)\n      document.addEventListener('mouseleave', this.moveEnd)\n      window.addEventListener('resize', this.refresh)\n    },\n    unbindEvents () {\n      window.removeEventListener('resize', this.refresh)\n      document.removeEventListener('touchmove', this.moving)\n      document.removeEventListener('touchend', this.moveEnd)\n      document.removeEventListener('mousemove', this.moving)\n      document.removeEventListener('mouseup', this.moveEnd)\n      document.removeEventListener('mouseleave', this.moveEnd)\n    },\n    getPos (e) {\n      this.realTime && this.getStaticData()\n      return e.clientX - this.offset\n    },\n    wrapClick (e) {\n      if (this.isDisabled || (!this.draggable && e.target.id === this.id)) return false\n      let pos = this.getPos(e)\n      this.setValueOnPos(pos)\n    },\n    moveStart (e, index) {\n      if (!this.draggable) return false\n      this.flag = true\n      this.$emit('dragStart', this)\n    },\n    moving (e) {\n      if (!this.flag || !this.draggable) return false\n      e.preventDefault()\n      if (e.targetTouches && e.targetTouches[0]) e = e.targetTouches[0]\n      this.setValueOnPos(this.getPos(e), true)\n    },\n    moveEnd (e) {\n      if (this.flag && this.draggable) {\n        this.$emit('dragEnd', this)\n        if (this.lazy && this.isDiff(this.val, this.value)) {\n          this.syncValue()\n        }\n      } else {\n        return false\n      }\n      this.flag = false\n      this.setPosition()\n    },\n    setValueOnPos (pos, isDrag) {\n      let range = this.limit\n      let valueRange = this.valueLimit\n      if (pos >= range[0] && pos <= range[1]) {\n        this.setTransform(pos)\n        let v = (Math.round(pos / this.gap) * (this.spacing * this.multiple) + (this.minimum * this.multiple)) / this.multiple\n        this.setCurrentValue(v, isDrag)\n      } else if (pos < range[0]) {\n        this.setTransform(range[0])\n        this.setCurrentValue(valueRange[0])\n        if (this.currentSlider === 1) this.currentSlider = 0\n      } else {\n        this.setTransform(range[1])\n        this.setCurrentValue(valueRange[1])\n        if (this.currentSlider === 0) this.currentSlider = 1\n      }\n    },\n    isDiff (a, b) {\n      if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n        return true\n      } else if (Array.isArray(a) && a.length === b.length) {\n        return a.some((v, i) => v !== b[i])\n      }\n      return a !== b\n    },\n    setCurrentValue (val, bool) {\n      if (val < this.minimum || val > this.maximum) return false\n      if (this.isDiff(this.currentValue, val)) {\n        this.currentValue = val\n        if (!this.lazy || !this.flag) {\n          this.syncValue()\n        }\n      }\n      bool || this.setPosition()\n    },\n    setIndex (val) {\n      val = this.spacing * val + this.minimum\n      this.setCurrentValue(val)\n    },\n    setValue (val, speed) {\n      if (this.isDiff(this.val, val)) {\n        let resetVal = this.limitValue(val)\n        this.val = resetVal\n        this.syncValue()\n      }\n      this.$nextTick(() => this.setPosition(speed))\n    },\n    setPosition (speed) {\n      if (!this.flag) this.setTransitionTime(speed === undefined ? this.speed : speed)\n      else this.setTransitionTime(0)\n      this.setTransform(this.position)\n    },\n    setTransform (val) {\n      let value = val - ((this.$refs.tooltip.scrollWidth - 2) / 2)\n      let translateValue = `translateX(${value}px)`\n      this.slider.style.transform = translateValue\n      this.slider.style.WebkitTransform = translateValue\n      this.slider.style.msTransform = translateValue\n      this.$refs.process.style.width = `${val}px`\n      this.$refs.process.style['left'] = 0\n    },\n    setTransitionTime (time) {\n      this.slider.style.transitionDuration = `${time}s`\n      this.slider.style.WebkitTransitionDuration = `${time}s`\n      this.$refs.process.style.transitionDuration = `${time}s`\n      this.$refs.process.style.WebkitTransitionDuration = `${time}s`\n    },\n    limitValue (val) {\n      if (this.data) {\n        return val\n      }\n      const inRange = (v) => {\n        if (v < this.min) {\n          this.printError(`[VueSlideBar warn]: The value of the slider is ${val}, the minimum value is ${this.min}, the value of this slider can not be less than the minimum value`)\n          return this.min\n        } else if (v > this.max) {\n          this.printError(`[VueSlideBar warn]: The value of the slider is ${val}, the maximum value is ${this.max}, the value of this slider can not be greater than the maximum value`)\n          return this.max\n        }\n        return v\n      }\n      return inRange(val)\n    },\n    syncValue () {\n      let val = this.val\n      if (this.range) {\n        this.$emit('callbackRange', this.range[this.currentIndex])\n      }\n      this.$emit('input', val)\n    },\n    getValue () {\n      return this.val\n    },\n    getIndex () {\n      return this.currentIndex\n    },\n    getStaticData () {\n      if (this.$refs.elem) {\n        this.size = this.$refs.elem.offsetWidth\n        this.offset = this.$refs.elem.getBoundingClientRect().left\n      }\n    },\n    refresh () {\n      if (this.$refs.elem) {\n        this.getStaticData()\n        this.setPosition()\n      }\n    },\n    printError (msg) {\n      console.error(msg)\n    }\n  },\n  mounted () {\n    this.isComponentExists = true\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      return this.printError('[VueSlideBar error]: window or document is undefined, can not be initialization.')\n    }\n    this.$nextTick(() => {\n      if (this.isComponentExists) {\n        this.getStaticData()\n        this.setValue(this.limitValue(this.value), 0)\n        this.bindEvents()\n      }\n    })\n  },\n  beforeDestroy () {\n    this.isComponentExists = false\n    this.unbindEvents()\n  }\n}\n</script>\n\n<style scoped>\n.vue-slide-bar-component {\n  position: relative;\n  box-sizing: border-box;\n  user-select: none;\n}\n.vue-slide-bar {\n  position: relative;\n  display: block;\n  border-radius: 15px;\n  background-color: #d8d8d8;\n  cursor: pointer;\n}\n.vue-slide-bar::after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 2;\n}\n.vue-slide-bar-process {\n  position: absolute;\n  border-radius: 15px;\n  background-color: #1066FD;\n  transition: all 0s;\n  z-index: 1;\n  width: 0;\n  height: 100%;\n  top: 0;\n  left: 0;\n  will-change: width;\n}\n.vue-slide-bar-tooltip-container {\n  position: absolute;\n  transition: all 0s;\n  will-change: transform;\n  cursor: pointer;\n  z-index: 3;\n  left: 0;\n  top: -16px;\n}\n.vue-slide-bar-tooltip-wrap {\n  /* display: none; */\n  position: absolute;\n  z-index: 9;\n  width: 100%;\n  height: 100%;\n  display: block !important;\n}\n.vue-slide-bar-tooltip-top {\n  top: -12px;\n  left: 40%;\n  transform: translate(-50%, -100%);\n}\n.vue-slide-bar-tooltip {\n  position: relative;\n  font-size: 14px;\n  white-space: nowrap;\n  padding: 2px 5px;\n  min-width: 20px;\n  text-align: center;\n  color: #fff;\n  border-radius: 5px;\n  border: 1px solid #1066FD;\n  background-color: #1066FD;\n}\n.vue-slide-bar-tooltip::before {\n  content: '';\n  position: absolute;\n  bottom: -10px;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border: 5px solid transparent;\n  border-top-color: inherit;\n  transform: translate(-50%, 0);\n}\n.vue-slide-bar-range {\n  display: flex;\n  padding: 5px 0;\n  justify-content: space-between;\n}\n.vue-slide-bar-separate {\n  position: relative;\n  width: 2px;\n  background-color: #9e9e9e;\n  height: 5px;\n  cursor: pointer;\n}\n.vue-slide-bar-separate-text {\n  text-align: center;\n  position: absolute;\n  white-space: nowrap;\n  transform: translate(-50%, 0);\n  top: 6px;\n}\n</style>\n","export default function normalizeComponent(compiledTemplate, injectStyle, defaultExport, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, isShadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n    if (typeof isShadowMode === 'function') {\n        createInjectorSSR = createInjector;\n        createInjector = isShadowMode;\n        isShadowMode = false;\n    }\n    // Vue.extend constructor export interop\n    const options = typeof defaultExport === 'function' ? defaultExport.options : defaultExport;\n    // render functions\n    if (compiledTemplate && compiledTemplate.render) {\n        options.render = compiledTemplate.render;\n        options.staticRenderFns = compiledTemplate.staticRenderFns;\n        options._compiled = true;\n        // functional template\n        if (isFunctionalTemplate) {\n            options.functional = true;\n        }\n    }\n    // scopedId\n    if (scopeId) {\n        options._scopeId = scopeId;\n    }\n    let hook;\n    if (moduleIdentifier) {\n        // server build\n        hook = function (context) {\n            // 2.3 injection\n            context =\n                context || // cached call\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\n            // 2.2 with runInNewContext: true\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n                context = __VUE_SSR_CONTEXT__;\n            }\n            // inject component styles\n            if (injectStyle) {\n                injectStyle.call(this, createInjectorSSR(context));\n            }\n            // register component module identifier for async chunk inference\n            if (context && context._registeredComponents) {\n                context._registeredComponents.add(moduleIdentifier);\n            }\n        };\n        // used by ssr in case component is cached and beforeCreate\n        // never gets called\n        options._ssrRegister = hook;\n    }\n    else if (injectStyle) {\n        hook = isShadowMode\n            ? function () {\n                injectStyle.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n            }\n            : function (context) {\n                injectStyle.call(this, createInjector(context));\n            };\n    }\n    if (hook) {\n        if (options.functional) {\n            // register for functional component in vue file\n            const originalRender = options.render;\n            options.render = function renderWithStyleInjection(h, context) {\n                hook.call(context);\n                return originalRender(h, context);\n            };\n        }\n        else {\n            // inject component registration as beforeCreate hook\n            const existing = options.beforeCreate;\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n        }\n    }\n    return defaultExport;\n}\n"],"names":["isOldIE","navigator","test","userAgent","toLowerCase","HEAD","document","head","getElementsByTagName","styles","script","compiledTemplate","injectStyle","defaultExport","scopeId","isFunctionalTemplate","moduleIdentifier","isShadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","this","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","id","style","css","group","media","ids","Set","has","code","source","map","sources","btoa","unescape","encodeURIComponent","JSON","stringify","element","createElement","type","setAttribute","appendChild","push","styleSheet","cssText","filter","Boolean","join","index","size","textNode","createTextNode","nodes","childNodes","removeChild","length","insertBefore","addStyle"],"mappings":";;;;;ggPAAA,MAAMA,EAA+B,oBAAdC,WACnB,gBAAgBC,KAAKD,UAAUE,UAAUC,eAI7C,MAAMC,EAAOC,SAASC,MAAQD,SAASE,qBAAqB,QAAQ,GAC9DC,EAAS,GCJf,UAEAC,qCCJ2CC,EAAkBC,EAAaC,EAAeC,EAASC,EAAsBC,EAAoCC,EAAcC,EAAgBC,EAAmBC,GAC7K,mBAAjBH,IACPE,EAAoBD,EACpBA,EAAiBD,EACjBA,GAAe,GAGnB,MAAMI,EAAmC,mBAAlBR,EAA+BA,EAAcQ,QAAUR,EAe9E,IAAIS,EAmCJ,GAhDIX,GAAoBA,EAAiBY,SACrCF,EAAQE,OAASZ,EAAiBY,OAClCF,EAAQG,gBAAkBb,EAAiBa,gBAC3CH,EAAQI,WAAY,EAEhBV,IACAM,EAAQK,YAAa,IAIzBZ,IACAO,EAAQM,SAAWb,GAGnBE,GAEAM,EAAO,SAAUM,IAEbA,EACIA,GACKC,KAAKC,QAAUD,KAAKC,OAAOC,YAC3BF,KAAKG,QAAUH,KAAKG,OAAOF,QAAUD,KAAKG,OAAOF,OAAOC,aAElB,oBAAxBE,sBACnBL,EAAUK,qBAGVrB,GACAA,EAAYsB,KAAKL,KAAMV,EAAkBS,IAGzCA,GAAWA,EAAQO,uBACnBP,EAAQO,sBAAsBC,IAAIpB,IAK1CK,EAAQgB,aAAef,GAElBV,IACLU,EAAOL,EACD,WACEL,EAAYsB,KAAKL,KAAMT,EAAqBS,KAAKS,MAAMC,SAASC,cAElE,SAAUZ,GACRhB,EAAYsB,KAAKL,KAAMX,EAAeU,MAG9CN,EACA,GAAID,EAAQK,WAAY,CAEpB,MAAMe,EAAiBpB,EAAQE,OAC/BF,EAAQE,OAAS,SAAkCmB,EAAGd,GAElD,OADAN,EAAKY,KAAKN,GACHa,EAAeC,EAAGd,QAG5B,CAED,MAAMe,EAAWtB,EAAQuB,aACzBvB,EAAQuB,aAAeD,EAAW,GAAGE,OAAOF,EAAUrB,GAAQ,CAACA,GAGvE,OAAOT,+1FFtEI,SAAwBe,GACnC,MAAO,CAACkB,EAAIC,KAIhB,SAAkBD,EAAIE,GAClB,MAAMC,EAAQjD,EAAUgD,EAAIE,OAAS,UAAYJ,EAC3CC,EAAQtC,EAAOwC,KAAWxC,EAAOwC,GAAS,CAAEE,IAAK,IAAIC,IAAO3C,OAAQ,KAC1E,IAAKsC,EAAMI,IAAIE,IAAIP,GAAK,CACpBC,EAAMI,IAAIf,IAAIU,GACd,IAAIQ,EAAON,EAAIO,OAkBf,GAjBIP,EAAIQ,MAGJF,GAAQ,mBAAqBN,EAAIQ,IAAIC,QAAQ,GAAK,MAElDH,GACI,uDACII,KAAKC,SAASC,mBAAmBC,KAAKC,UAAUd,EAAIQ,QACpD,OAEPT,EAAMgB,UACPhB,EAAMgB,QAAUzD,SAAS0D,cAAc,SACvCjB,EAAMgB,QAAQE,KAAO,WACjBjB,EAAIE,OACJH,EAAMgB,QAAQG,aAAa,QAASlB,EAAIE,OAC5C7C,EAAK8D,YAAYpB,EAAMgB,UAEvB,eAAgBhB,EAAMgB,QACtBhB,EAAMtC,OAAO2D,KAAKd,GAClBP,EAAMgB,QAAQM,WAAWC,QAAUvB,EAAMtC,OACpC8D,OAAOC,SACPC,KAAK,UAET,CACD,MAAMC,EAAQ3B,EAAMI,IAAIwB,KAAO,EACzBC,EAAWtE,SAASuE,eAAevB,GACnCwB,EAAQ/B,EAAMgB,QAAQgB,WACxBD,EAAMJ,IACN3B,EAAMgB,QAAQiB,YAAYF,EAAMJ,IAChCI,EAAMG,OACNlC,EAAMgB,QAAQmB,aAAaN,EAAUE,EAAMJ,IAE3C3B,EAAMgB,QAAQI,YAAYS,MA1ChBO,CAASrC,EAAIC"}